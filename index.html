<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Accelerometer Example</title>
    <style>
        #object {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div id="object"></div>
    <div id="Object_x"></div>
    <div>
        <label for="sensitivitySlider">Sensitivity: </label>
        <input type="range" id="sensitivitySlider" min="0.1" max="2" step="0.1" value="0.5">
    </div>
    <button id="start_demo">Start Demo</button>

    <script>
        const object = document.getElementById("object");
        const sensitivitySlider = document.getElementById("sensitivitySlider");
        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;

        // Center the object in the middle of the screen
        function centerObject() {
            const initialLeft = (screenWidth - object.offsetWidth) / 2;
            const initialTop = (screenHeight - object.offsetHeight) / 2;
            object.style.left = `${initialLeft}px`;
            object.style.top = `${initialTop}px`;
            updateField("Object_x", Math.round(initialLeft));
        }

        centerObject(); // Center the object initially

        function updateField(fieldName, value) {
            document.getElementById(fieldName).innerHTML = value;
        }

        const sensitivity = parseFloat(sensitivitySlider.value);
        let lastX = 0; // Last processed position

        function handleMotion(event) {
            const accelerationX = event.accelerationIncludingGravity.x || 0;

            // Only update if significant move to reduce sensitivity
            if (Math.abs(accelerationX - lastX) > sensitivity) {
                lastX = accelerationX;

                const currentLeft = object.offsetLeft;
                let newLeft = currentLeft + accelerationX;

                // Smooth movement with requestAnimationFrame
                requestAnimationFrame(() => {
                    object.style.left = `${Math.max(0, Math.min(screenWidth - object.offsetWidth, newLeft))}px`;
                    updateField("Object_x", Math.round(object.offsetLeft));
                });
            }
        }

        const demo_button = document.getElementById("start_demo");
        demo_button.onclick = function (e) {
            e.preventDefault();

            // Request permission for iOS 13+ devices
            if (DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission().then(response => {
                    if (response === 'granted') {
                        window.addEventListener("devicemotion", handleMotion);
                    }
                }).catch(console.error);
            } else {
                window.addEventListener("devicemotion", handleMotion);
            }
        };

        // Handle screen resize to keep object centered
        window.onresize = function () {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            centerObject(); // Re-center the object when the window size changes
        };
    </script>
</body>

</html>